#version 440
layout(local_size_x = 1, local_size_y = 1) in;
//using image2D instead of sampler, we can write anywhere in the image?
layout(rgba32f, binding = 0) uniform image2D img_output; 
//

uniform mat4 model[3];
uniform mat4 model_inv[3];
uniform int type[3];

float intersectSphere(vec3 ray_o, vec3 ray_d){
	
	
	vec3 omc = ray_o - vec3(0,0,0);
	float b = dot(ray_d, omc);
	float c = dot(omc, omc) - 1;
	//float a = dot(ray_d,ray_d); //unnecessary if ray direction is normalized
	float a=1; //change if needed
	float bsqmc = b * b - c; //truly 4bÂ²-4ac
	if(bsqmc>0)
	{
		//return bsqmc;
		float d = sqrt(bsqmc);
		float t1=-b+d;
		float t2=-b-d;
		if(t2>0) 
			return t2;
		else 
			return t1;
	}
	
	else
		return -1;
	
		
	
	  
}

float intersectPlane(vec3 ray_o, vec3 ray_d, vec3 plane_n, float plane_D){
  float nd=dot(plane_n,ray_d);
  if(abs(nd)< 1e-20){ //TODO: machine precision
	  //TODO: parallel
	  return -1;
  } else {
	  float t=-(plane_D+dot(plane_n,ray_o))/nd;
	  return t;
  }
	  
  
}

float diffuse(vec3 dirL, vec3 normal)
{
    float color=max(0.0,dot(dirL,normal));
    return color;
}

vec2 intersect(vec3 ray_o,vec3 ray_d, vec3 plane_n, float plane_D)
{
	float t=10000.0; //TODO: machine numbers...
	int index=0;
	for (int j=0; j<3; j++){
		vec3 ray_oj=(model_inv[j]*vec4(ray_o,1.0)).xyz;
		vec3 ray_dj=(model_inv[j]*vec4(ray_d,0.0)).xyz;
		if(type[j]==1){
			float tS= intersectSphere(ray_oj, ray_dj);
			if((tS>0) &&(tS<t)){
				t=tS;
				index=j;
			}
		}else{
			float tP=intersectPlane( ray_o, ray_d, plane_n , plane_D);
			if((tP>0) &&(tP<t)){
				t=tP;
				index=j;
			}
				
		}
	}
	vec2 outval = vec2(t,index);
	return outval;
	
}

void main() {
	
	// base pixel colour for image
	vec4 pixel = vec4(0.2, 0.2, 0.2, 1.0);
	// get index in global work group i.e x,y position
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
  
	//----------------projection + view + light (hardcoded for now)--------------------
	float max_x = 5.0;
	float max_y = 5.0;
	ivec2 dims = imageSize(img_output); // fetch image dimensions
	float x = (float(pixel_coords.x * 2 - dims.x) / dims.x); //--->[-1,1]
	float y = (float(pixel_coords.y * 2 - dims.y) / dims.y); //--->[-1,1]
  
	vec3 pixel_position=vec3(x * max_x, y * max_y, -10.0);
	vec3 ray_o=vec3(0.0,0.0,0.0);
	vec3 ray_d=normalize(pixel_position-ray_o);
	vec3 light =vec3(5,5,-6);
  
	//planeparameters, for now
	vec3 plane_n=normalize(vec3(0,1,0));
	float plane_D=1;
  
	//--------------- bounces----------------------------------------------------------

	
	vec2 outval=intersect(ray_o,ray_d, plane_n, plane_D);
	float t=outval[0];
	int ind=int(outval[1]);
	
	vec4 color=vec4(0.4, 1.0, 0.4, 1.0);
	
	
	if((t>0) && (t<10000.0)){
	
		vec3 position = ray_o+t*ray_d;
		vec3 dirL=normalize(light-position);
		vec3 normal=vec3(0,1,0);
		
		float kr=0;
		
		if(type[ind]==1){
			normal=normalize(position-(model[ind]*vec4(0,0,0,1)).xyz);
			//color=vec4(0.4, 0.4, 1.0, 1.0);
			kr=0.5;
		} else
		{
			normal=plane_n;
			kr=0.5;
		}
		if(ind==0)
			color=vec4(1.0, 0.4, 0.4, 1.0);
		if(ind==1)
			color=vec4(0.4, 0.4, 1.0, 1.0);
		if(ind==2)
			color=vec4(0.4, 1.0, 0.4, 1.0);
			
			
		float colori=diffuse(dirL, normal);
		
		//------------------shadow-----------------------------------
		outval=intersect(position+0.0001*dirL,dirL, plane_n, plane_D); // for my geometry, way too much calculations...
		
		float shadow = 1;
		if((outval[0]>0) && (outval[0]<10000.0))
			shadow =0;
		
		
		//---------------second bounce--------------------------------
		vec3 ray_d2=normalize(ray_d-2*dot(ray_d,normal)*normal);
		vec3 ray_o2=position+0.0001*ray_d2;
		outval=intersect(ray_o2,ray_d2, plane_n, plane_D);
		
		t=outval[0];
		ind=int(outval[1]);
		vec4 color2=vec4(0.0, 0.0, 0.0, 1.0);
		
		
		
		if((t>0) && (t<10000.0)){
			
			vec3 position2 = ray_o2+t*ray_d2;
			vec3 dirL2=normalize(light-position2);
			vec3 normal2=vec3(0,1,0);
				
				
			if(type[ind]==1){
				normal2=normalize(position2-(model[ind]*vec4(0,0,0,1)).xyz);
				//color2=vec4(0.4, 0.4, 1.0, 1.0);
				
			} else {
				normal2=plane_n;
				//color2=vec4(0.4, 1.0, 0.4, 1.0);
				
			}
			
			if(ind==0)
				color2=vec4(1.0, 0.4, 0.4, 1.0);
			if(ind==1)
				color2=vec4(0.4, 0.4, 1.0, 1.0);
			if(ind==2)
				color2=vec4(0.4, 1.0, 0.4, 1.0);
			
			float colori2=diffuse(dirL2, normal2);
			color2=vec4(vec3(colori2),1)*color2;
		}
		
		
		pixel = shadow*vec4(vec3(colori),1)*color+kr*color2;
  }

	//pixel = vec4(normal,1);
  
  imageStore(img_output, pixel_coords, pixel);
}